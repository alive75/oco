# Orçamento do Casal Organizado (OCO) - Diretrizes para Claude Code

## Contexto do Projeto
Você está desenvolvendo uma aplicação web de gerenciamento financeiro para uso pessoal de um casal. O app implementa Zero-Based Budgeting com entrada manual de transações e gestão compartilhada de despesas.

## Stack Técnica

### Backend
- **Framework**: NestJS (Node.js)
- **Banco de Dados**: PostgreSQL
- **ORM**: TypeORM
- **Autenticação**: JWT + Passport
- **Validação**: class-validator e class-transformer
- **Documentação**: Swagger

### Frontend  
- **Framework**: React 18+ com TypeScript
- **Estilização**: Tailwind CSS
- **Componentes**: Shadcn UI
- **Validação de Forms**: React Hook Form + Zod
- **Gerenciamento de Estado**: Zustand
- **Cliente HTTP**: Axios
- **Build Tool**: Vite

## Estrutura de Dados Principal

### Usuários (Fixos)
- Apenas 2 usuários no sistema
- Login via email/senha
- Sem registro público

### Hierarquia do Orçamento
```
Mês/Ano
└── Grupos
    └── Categorias
        └── Valor Alocado
```

### Tipos de Conta
1. **Corrente**: Conta padrão
2. **Cartão de Crédito**: Cria categoria automática para pagamento
3. **Investimentos**: Para tracking de patrimônio

### Transações
- Sempre vinculadas a uma conta
- Podem ser compartilhadas (50/50) ou individuais
- Tipos especiais não afetam orçamento: Transferência, Renda, Saque

## Regras de Negócio Críticas

### Zero-Based Budgeting
1. Todo valor de renda deve ser alocado em categorias
2. "Pronto para atribuir" = Renda Total - Soma das Alocações
3. Objetivo é sempre chegar a zero no "Pronto para atribuir"

### Cartão de Crédito
1. Quando criado, gera categoria com mesmo nome automaticamente
2. Transação no cartão com categoria X:
   - Deduz do saldo da categoria X
   - Adiciona à categoria do cartão (para pagamento futuro)
3. Pagamento da fatura é uma transferência da conta para o cartão

### Despesas Compartilhadas
1. Transações marcadas como "compartilhada" entram no cálculo mensal
2. Sistema calcula automaticamente quem deve para quem
3. Divisão sempre 50/50 entre o casal

## Padrões de Código

### Backend (NestJS)
```typescript
// Use decorators do NestJS
@Controller('budgets')
export class BudgetController {
  @Post()
  @UseGuards(JwtAuthGuard)
  create(@Body() dto: CreateBudgetDto) {}
}

// DTOs com validação
export class CreateBudgetDto {
  @IsString()
  @IsNotEmpty()
  name: string;
  
  @IsNumber()
  @Min(0)
  allocatedAmount: number;
}
```

### Frontend (React)
```tsx
// Componentes funcionais com TypeScript
interface TransactionFormProps {
  accountId: string;
  onSubmit: (data: TransactionData) => void;
}

export function TransactionForm({ accountId, onSubmit }: TransactionFormProps) {
  // Use React Hook Form com Zod
  const form = useForm<TransactionData>({
    resolver: zodResolver(transactionSchema)
  });
  
  return (
    // Use Shadcn UI components
    <Form {...form}>
      {/* ... */}
    </Form>
  );
}

// Gerenciamento de Estado com Zustand
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface AuthState {
  user: User | null;
  token: string | null;
  login: (credentials: LoginDto) => Promise<void>;
  logout: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      token: null,
      login: async (credentials) => {
        const { user, token } = await authService.login(credentials);
        set({ user, token });
      },
      logout: () => set({ user: null, token: null })
    }),
    { name: 'auth-storage' }
  )
);

// Cliente HTTP com Axios
import axios from 'axios';

export const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3000',
  timeout: 10000
});

// Interceptor para JWT
api.interceptors.request.use(config => {
  const token = useAuthStore.getState().token;
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
```

## Prioridades de Desenvolvimento

### Must Have (MVP)
1. ✅ Autenticação básica (2 usuários)
2. ✅ CRUD de orçamento (grupos/categorias)
3. ✅ CRUD de contas
4. ✅ CRUD de transações
5. ✅ Cálculo de despesas compartilhadas
6. ✅ Lógica do cartão de crédito
7. ✅ Interface responsiva básica

### Nice to Have (Pós-MVP)
- Gráficos e relatórios
- Histórico de meses anteriores
- Export de dados
- Metas de economia

## Convenções

### Nomenclatura
- **Variáveis/Funções**: camelCase
- **Componentes React**: PascalCase
- **Arquivos**: kebab-case
- **Constantes**: UPPER_SNAKE_CASE

### Git
- Commits em português
- Mensagens descritivas
- Branch main para produção

### API REST
- **GET** /resource - Listar
- **GET** /resource/:id - Buscar um
- **POST** /resource - Criar
- **PATCH** /resource/:id - Atualizar parcial
- **DELETE** /resource/:id - Deletar

## Segurança Mínima
- Senhas com bcrypt (salt rounds: 10)
- JWT com expiração de 7 dias
- CORS configurado
- Validação de entrada em todos endpoints
- HTTPS em produção

## Deploy
- Backend: Server Node.js (PM2 recomendado)
- Frontend: Build estático (Nginx)
- Banco: PostgreSQL 14+
- Ambiente: Linux/Docker

## Comandos Úteis

```bash
# Backend
npm run start:dev     # Desenvolvimento
npm run build        # Build produção
npm run migration:run # Rodar migrations

# Frontend  
npm run dev          # Desenvolvimento
npm run build        # Build produção
npm run preview      # Preview do build

# Database
npm run typeorm migration:generate -- -n MigrationName
npm run typeorm migration:run
```

## Observações Importantes

1. **Não implementar** integração bancária - todas transações são manuais
2. **Não implementar** sistema de multi-tenancy - apenas 2 usuários fixos
3. **Manter simples** - é uma ferramenta pessoal, não comercial
4. **Priorizar funcionalidade** sobre beleza visual
5. **Evitar over-engineering** - YAGNI (You Aren't Gonna Need It)

## Fluxo de Trabalho Recomendado

1. Sempre começar pelo backend (API primeiro)
2. Testar endpoints com Thunder Client ou Insomnia
3. Implementar frontend após API estar funcional
4. Fazer commits frequentes e pequenos
5. Testar em ambiente local antes de deploy
